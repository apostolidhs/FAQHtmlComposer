Η ανάθεση ενός πίνακα με μία τυχαία μεταβλητή, επηρεάζει το reference count του, έτσι υπάρχει περίπτωση ο πίνακας να μην καταστρέφεται όταν ο χρήστης θέσει όλα τα references του με nil;
-------------------------
Όντος, αυτό ισχύει και μάλιστα όταν ο πίνακας βρίσκεται στο global scope, υπάρχει περίπτωση να κρατηθεί ζωντανός σε όλη τη ζωή του προγράμματος (στο τέλος του προγράμματος θα γίνει σίγουρα collect) ακόμα κι αν ο χρήστης του θέσει ρητά την τιμή **nil**. Όμως αυτή η συμπεριφορά δεν αλλάζει καθόλου τη σημασιολογία του reference counting των πινάκων, αφού έτσι κι αλλιώς ο χρήστης (προγραμματιστής της γλώσσας), δεν μπορεί να βασίσει την ορθότητα του προγράμματος του στην γνώση καταστροφής ενός πίνακα σε συγκεκριμένη χρονική στιγμή. Έτσι αυτή η συμπεριφορά, είναι απόλυτα αποδεκτή.
Ένας “νεκρός” -για τον χρήστη- πίνακας μπορεί να μην καταστραφεί από το runtime σύστημα άμεσα, όμως δεδομένου ότι
*    Υπάρχει μία υποτυπώδης επαναχρησιμοποίηση των προσωρινών μεταβλητών
*    Οι μεταβλητές που έχουν οριστεί μέσα στο σώμα μίας συνάρτησης μετά την κλήση της είναι σίγουρο ότι πεθαίνουν
*    Ένα απλό πέρασμα βελτιστοποίησης (optimization pass), μπορεί πολύ εύκολα να εντοπίσει και να απαλείψει “νεκρές” μεταβλητές
είναι σίγουρο ότι σε γενικές γραμμές το ποσοστό της άχρηστης μνήμης που θα παραμένει δεσμευμένη ανά πάσα στιγμή θα είναι πολύ μικρό.
